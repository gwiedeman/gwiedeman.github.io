<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="XQuery for Archivists: Understanding EAD Finding Aids as Data">
    <meta name="author" content="Gregory Wiedeman">

    <title>XQuery for Archivists: Understanding EAD Finding Aids as Data</title>

    <!-- Bootstrap Core CSS -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">
	
	<link href="../css/font-awesome.min.css" rel="stylesheet">
	
	<link href="../css/bootstrap-social.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../css/main.css" rel="stylesheet">
    <link href="../css/writing.css" rel="stylesheet">
	
	<!--Code styleing -->
	<script type="text/javascript" src="../js/shCore.js"></script>
	<script type="text/javascript" src="../js/shBrushPython.js"></script>
	<script type="text/javascript" src="../js/shBrushXml.js"></script>
	<link href="../css/shCore.css" rel="stylesheet" type="text/css" />
	<link href="../css/shThemeDefault.css" rel="stylesheet" type="text/css" />
	
	<!-- Fonts -->
	<link href='https://fonts.googleapis.com/css?family=Bree+Serif|Open+Sans|Roboto+Slab' rel='stylesheet' type='text/css'>
	
	<script type='text/javascript' src='../js/main.js'></script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-87697094-1', 'auto');
  ga('send', 'pageview');

</script>
</head>

<!-- The #page-top ID is part of the scrolling feature - the data-spy and data-target are part of the built-in Bootstrap scrollspy function -->

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-custom navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand page-scroll" href="../index.html#page-top">Greg Wiedeman</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse navbar-ex1-collapse">
                <ul class="nav navbar-nav">
                    <!-- Hidden li included to remove active class from about link when scrolled up past about section -->
                    <li class="hidden">
                        <a class="page-scroll" href="../index.html#page-top"></a>
                    </li>
					<li>
                        <a class="page-scroll" href="../index.html#about">About</a>
                    </li>
                    <li>
                        <a class="page-scroll" href="../index.html#writing">Writing</a>
                    </li>
                    <li>
                        <a class="page-scroll" href="../index.html#presentations">Presentations</a>
                    </li>
					<li>
                        <a class="page-scroll" href="../index.html#code">Code</a>
                    </li>
                    <li>
                        <a class="page-scroll" href="../index.html#cv">CV</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

   
    <!-- Writing Section -->
    <section id="writing" class="writing-section">
        <div class="container">
            <div class="row">
                <div class="col-lg-10 col-lg-offset-1 col-sm-10 col-sm-offset-1 col-xs-12">
					<section class="text-header">
						<div class="jumbotron">
							<h1>XQuery for Archivists: Understanding EAD Finding Aids as Data</h1>
							<h5>2014 October</h5>
							<p>XML has long been an important tool for archivists. The addition of XQuery provides a simple and easy-to-learn tool to extract, transform, and manipulate the large amounts of XML data that archival repositories have committed resources to develop and maintain – particularly EAD finding aids. XQuery allows archivists to make use of that data. Furthermore, using XQuery to query EAD finding aids, rather than merely reformat them with XSLT, forces archivists to look at finding aids as data. This will provide better knowledge of how EAD may be used and further understanding of how finding aids may be better encoded. This article provides a simple how-to guide to get archivists to start experimenting with XQuery.</p>
							<h5>Published in <a href="http://practicaltechnologyforarchives.org/issue3_wiedeman/"><em>Practical Technology for Archives&nbsp;</em>&nbsp;Issue 3</a></h5>
						</div>
					</section>
					<section class="text-body">
						<p>XQuery is a simple, yet powerful, scripting language designed to enable users without formal programming training to extract, transform, and manipulate XML data. Moreover, the language is an accepted standard and a W3C recommendation much like its sister standards, XML and XSLT. In other words, XQuery’s <em>raison d&#8217;etre</em> coincides perfectly with the needs of today’s archivists. What follows is a brief, pragmatic, overview of XQuery for archivists that will enable archivists with a keen understanding of XML, XPath, and EAD to begin experimenting with manipulating EAD data using XQuery.</p>
<p>Archivists do not need to be sold on XML – repositories around the country have been early adopters to the technology since the 1990s. Essentially all archives data standards have been either developed for XML (EAD) or been adapted for its use (MARC). The openness, standardization, structural flexibility, and ease of use have proven that XML is a powerful and central tool for the 21st century archivist. Yet, while archivists have long stored finding aids in EAD, there is a major skill difference between encoding finding aids and actually doing anything with that data.<a class="ftnref" id="ftnref1" href="#ftn1">[1]</a> The most typical way archivists have made use of XML data is through XSLT stylesheets, often to display data in long, scrollable lists. More recently, there has been a movement to develop more sophisticated and user-friendly archival information systems.<a class="ftnref" id="ftnref2" href="#ftn2">[2]</a> Furthermore, archives that have so heavily invested in developing EAD finding aids would love to automate the repurposing this data for easier access, outreach activities, and more. Quite simply, manipulating and reformatting XML data has become a valuable skill for archivists and XQuery provides a simple and easy-to-learn method to do just that.</p>
<p>This is by no means even a comprehensive introduction to XQuery – for that, archivists will need to seek more traditional resources like those supplied at the end of this article. Yet, starting with a long and comprehensive study of XQuery may serve only to delay hands-on experience and frustrate the impatient. Archivists may find it easier to dive in and experiment with the language before seeking a broader understanding. What archivists need is a simple and accessible guide to get them started. If you run into trouble while using this guide, try searching for your problem either at Stack Overflow or with your favorite search engine.<a class="ftnref" id="ftnref3" href="#ftn3">[3]</a></p>
<h3>XQuery and XSLT</h3>
<p>Now, to archivists who have had some experience with XSLT, XQuery sounds a lot like these XML stylesheet transformations. XSLT can also be used to transform and manipulate XML data, was put into widespread use well before XQuery, and has the advantage of being compiled by web browsers. This means XML data can be processed server-side with XSLT whereas today’s browsers are unable to read XQuery without specialized add-ons or workarounds. Archivists have not had to learn and adapt to new software to try XSLT – they have just experimented with stylesheet transformations by using their familiar web browser. This may be why XSLT has enjoyed much more use within the archives community. Graduate schools have commonly taught XSLT and many archivists have spent a considerable amount of time learning the standard. Yet, while XSLT and XQuery do overlap in some ways, there are a few important distinctions that make the latter more useful in many cases. </p>
<h3>Why XQuery?</h3>
<p>So why use or learn XQuery? Most importantly, it is much simpler and less verbose than XSLT, which is written in XML itself. This makes XSLT require more characters to perform the same actions than XQuery (see appendix for comparison). While this does not seem like a huge advantage, it actually is. XQuery scripts are cleaner, simpler, often quicker to write, and much easier to maintain. This makes users much more likely to actually use the language and make more effective use of their XML data. As Steve Krug famously argued about usability testing: if a task is difficult it will be avoided, while if a task is easier the more likely that it will be performed more often.<a class="ftnref" id="ftnref4" href="#ftn4">[4]</a> Archivists who have avoided updating large XSLT files derived long ago from the original EAD cookbook will certainly sympathize.<a class="ftnref" id="ftnref5" href="#ftn5">[5]</a></p>
<p>Secondly, XQuery is more powerful than XSLT. It can perform more functions and make complex tasks easier. Functions are central to both languages – think of them as pre-programmed magic words that help users to easily perform complex actions with their data. In XQuery, advanced users can even write their own functions more easily than in XSLT. While XSLT 3.0 has introduced more functions, this does not even compare to XQuery which has 225 built-in functions that can easily check if an element exists or contains data, edit character strings in complex ways, determine the relative positions of elements, and many more tools that enable users to get the most out of their data.</p>
<p>So, XQuery enables archivists to do more with their data, and makes them much more likely to do it. Yet, the biggest advantage might be that it forces them to think of EAD files as data not as a list or index. Unlike XSLT, XQuery is designed to query XML – it is designed so that users ask what data they want and how they want it. This will force archivists to see their descriptions as discrete units of information. Not only do descriptions have contextual relationships with surrounding descriptions that convey original order, but it can also be useful to return discrete descriptions as search results or reorder data to show information in different (and perhaps more accessible) ways. This is consistent with recent arguments that single levels of EAD finding aids are useful as discrete elements for navigation and will overall serve to further distance EAD from the display that researchers see.<a class="ftnref" id="ftnref6" href="#ftn6">[6]</a> Thus, EAD will become a data store of archival description while an additional interface or information system queries it rather than transforming or reformatting it.</p>
<h3>What Do I Need to Use XQuery?</h3>
<p>While XQuery cannot run natively in common browsers, there are a number of ways to begin experimenting with querying XML. First, Saxon processes XQuery as well as XSLT, so if you have access to desktop software such as Oxygen XML Editor or a server that is running Saxon, you should be able to run queries much like you run XSLT.<a class="ftnref" id="ftnref7" href="#ftn7">[7]</a> Saxon can also be set up to run on a desktop using the Java Runtime Environment though the command line. Additionally, eXist-db is an open source XML database built specifically to run XQuery with a RESTful architecture – essentially, eXist is meant to be part of the back end of a typical web service.<a class="ftnref" id="ftnref8" href="#ftn8">[8]</a> Here the software runs on a server (or is simulated using the Java Runtime Environment) and users log on to a web interface to upload and manage XML data. XQuery scripts can then be run within web pages by end-users. Since HTML is XML itself, with eXist XQuery can edit, transform and query HTML and function much like a server-side scripting language. The Princeton University Library Finding Aids make use of eXist-db. Finally, Zorba is an XQuery processor that can run in the command line or as an extension to PHP or Python.<a class="ftnref" id="ftnref9" href="#ftn9">[9]</a>  This enables XQuery to be run within server-side PHP or Python web applications.</p>
<p>The above methods for running XQuery scripts might seem scary or confusing to many archivists, particularly those with little experience with servers and web architecture. This, compared to native browser support, seems to be one of the reasons XSLT has remained popular. However, there are also easier and more accessible ways to experiment with XQuery. After all, it is just text.</p>
<p>Perhaps the easiest way to begin playing with XQuery is using BaseX, a communally-developed open-source XML database with a desktop GUI interface.<a class="ftnref" id="ftnref10" href="#ftn10">[10]</a> Most importantly, BaseX is platform independent and can be installed on any recent Windows or Mac desktop machine like any typical program. The program is also BSD-licensed, meaning it is free to download and use with attribution. The best thing about BaseX GUI is its simplicity. By default, the interface has four major panes, or windows: an Editor pane, which includes a Project pane for selecting files; a Query Info pane; and a Results pane. The Editor and Results panes are most important to new users that might be overwhelmed by seeing too much of the back-end. The Editor pane functions much like a basic text editor: XQuery scripts can be written manually and files can be opened or saved using icons. After a script is written, a user can press the “Execute query” icon, which looks like a play symbol, and the result shows up in the Results pane. Here the result can be saved or overwritten by a new result by running another query. This simplicity allows for easy trial and error, important for archivists inexperienced with programming to experiment with manipulating data.</p>
<div class="figure">
  <img src="img/xquery2.jpg" width="1000" /></p>
<p><strong>Figure 1:</strong> Screenshot of BaseX GUI running on Windows 7</p>
</div>
<h3>Learning the Language, Structure, and Syntax</h3>
<p>There are two sections of an XQuery script: a <em>prolog</em> and a <em>body</em>. The prolog is optional, comes before the body, and acts like a header to declare namespaces, variables and some structural parts of XML results such as encoding. Since the goal of this piece is to get archivists started with XQuery as quickly and easily as possible, we will only declare a version and an input document in our prolog:</p>
<div class="code">
<pre class="brush: xml">
xquery version "3.0";
declare variable $doc := doc(path/to/EAD.xml);
</pre>
</div>
<p>The first line specifies the version of the XQuery script and the second line declares the variable $doc as the EAD file we want to query. Variables can be any single word with no spaces preceded by a dollar sign ($). We could just as easily use $ead, $xml, or whatever we like in place of $doc. The next doc() in the second line is not a variable, but a function that specifically reads an xml document. Users can also replace the doc() function with collection() and point to a folder instead of a file. This will assign multiple files in a directory to the $doc variable. Each statement in the prolog is followed by a semicolon (;), and after the last prolog statement, the query body begins. Now when we query the variable $doc later in the body, BaseX will know that we mean our EAD file.</p>
<p>In the query body there are two main types of statements you will use most often: FLOWR expressions and IF expressions. FLOWR stands for For, Let, Order by, Where, and Return – the likely questions you will ask of your data (essentially the who, what, where, why, and when). Here is a sample FLOWR expression for querying an EAD file:</p>
<div class="code">
<pre class="brush: xml">
xquery version "3.0";
declare variable $doc := doc(path/to/EAD.xml);

for $series in $doc/ead/archdesc/dsc/c01
let $extent := $series/did/physdesc/extent
where $series/@level = 'series'
order by  $extent
return $series/did/unittitle
</pre>
</div>
<p>For is the first part of a FLOWR expression, think of it as “for each,” as the rest of the expression will be performed on each tag it finds in the path given. This statement looks for each &lt;c01&gt; tag in the container list within the variable $doc (our EAD file) and assigns each tag it discovers to the variable $series. We just selected each top-level series from our EAD file. The second line declares another variable ($extent) to represent the contents of each series’ &lt;extent&gt; tag within its &lt;did&gt; and &lt;physdesc&gt; tags. The third line where statement limits all &lt;c01&gt; tags to only those which a “level” attribute with the value “series” (&lt;c01 level=”series”/&gt;). The fourth line orders each remaining &lt;c01&gt; tag by the variable ($extent) declared in line two. In our department, the &lt;extent&gt; tag contains each series’ extent in cubic feet, so this line re-orders each &lt;c01&gt; tag by its extent. Finally, the fourth line returns a result. We could ask to just return $series, but that would return each &lt;c01&gt; tag as well its contents – including its &lt;did&gt; tag and any lower components in the container list. Thus we will only ask specifically for each &lt;c01&gt; tag’s title. The result of this query will return each series title ordered by size. Archivists looking to experiment with XQuery should copy and paste this code into BaseX’s Editor pane and point the path in the prolog to an EAD file. Next you should experiment by erasing some code and adding to it in stages to see how each change alters the results. FLOWR expressions only require one of either for or let and a return.</p>
<p>Now we can also add our own XML tags to the result, differentiating from the query return with curly brackets ({ and }). This adds greatly to the utility of XQuery but also introduces some additional complexity.</p>
<div class="code">
<pre class="brush: xml">
xquery version "3.0";
declare variable $doc := doc(path/to/EAD.xml);

for $series in $doc/ead/archdesc/dsc/c01
let $extent := $series/did/physdesc
where $series/@level = 'series'
order by  $extent
return &lt;FileSeries&gt;{$series/did/unittitle}&lt;/FileSeries&gt;
</pre>
</div>
<p>If we plug this query into BaseX we will realize that this expression results in each series also retaining its original &lt;unittitle&gt; tag. Using the data() function will only return the contents of the selected tag. Replace the last line in the code above with the line here:</p>
<div class="code">
<pre class="brush: xml">
return &lt;FileSeries&gt;{data($series/did/unittitle)}&lt;/FileSeries&gt;
</pre>
</div>
<p>Functions are the magic words that make XQuery so powerful. They perform actions on the contents within their parenthesis. So far we have used two functions: data() and doc() in our prolog. The XQuery 3.0 standard includes 225 built-in functions and many more are available on the FunctX XQuery Function Library website.<a class="ftnref" id="ftnref11" href="#ftn11">[11]</a> Often, the simplest place to enter these functions is within a let clause. Here we have our same query with the addition of the upper-case() function.</p>
<div class="code">
<pre class="brush: xml">
xquery version "3.0";
declare variable $doc := doc(path/to/EAD.xml);

for $series in $doc/ead/archdesc/dsc/c01
let $extent := $series/did/physdesc
where $series/@level = 'series'
let $UPPERseries := upper-case($series/did/unittitle)
order by  $extent
return &lt;FileSeries&gt;{$UPPERseries}&lt;/FileSeries&gt;
</pre>
</div>
<p>This query declares a new variable $UPPERseries which performs the function upper-case() on the title of our old $series variable. When we return the new variable it will be in all capital letters.<br />
In addition to FLOWR expressions, XQuery users will often employ IF expressions. These expressions are useful to make conditionals that accept the large amount of variability that is often present in archival data.</p>
<div class="code">
<pre class="brush: xml">
xquery version "3.0";
declare variable $doc := doc(path/to/EAD.xml);

if ($doc/ead/archdesc/did/physdesc/extent &lt; 20)
then (&lt;size&gt;{data($doc/ead/archdesc/did/physdesc/extent)}&lt;/size&gt;)
else (&lt;size&gt;This collection is large.&lt;/size&gt;)
</pre>
</div>
<p>In the first line this IF expression in the XQuery body tests whether the collection is smaller than 20 cubic feet. The second and third lines offer two options that depend on whether or not the first line is true. The query either returns the extent of the collection or text that states the collection is large. You may get an error if the EAD file you are using contains more than a number in the &lt;extent&gt; tag. Try experimenting by changing the less than operator (&lt;) to a greater than (&gt;), equal (=), or not equal (!=) operator. A more complex IF expression might draw different results if an EAD container list has more than one or two levels of arrangement.</p>
<h3>Manipulating Data from EAD Finding Aids</h3>
<p>Now that we have experimented using FLOWR expressions, functions, and IF expressions, we can manipulate our data in many powerful ways. Not only can XML be entered in a return statement, but an entire query can be placed within XML tags. Here is a more complex XQuery script that summarizes a set of EAD files:</p>
<div class="code">
<pre class="brush: xml">
xquery version "3.0";

&lt;Repository&gt;
{
for $collection in collection('path/to/EAD/files')
let $info := $collection/ead/archdesc
let $date := $info/did/unitdate[@type = 'inclusive']
order by $date/@normal
return 
  &lt;Collection&gt;
    &lt;Title&gt;{data($info/did/unittitle)}&lt;/Title&gt;
    &lt;Date&gt;{data($date)}&lt;/Date&gt;
    &lt;Size&gt;{data($info/did/physdesc)}&lt;/Size&gt;
    &lt;Arrangement&gt;
      {
        if ($info/dsc/c01/@level = 'series')
        then
          (
            for $series in $collection/ead/archdesc/dsc/c01
            where $series/@level = 'series'
            return &lt;Series&gt;{data($series/did/unittitle)}&lt;/Series&gt;
          )
        else (&lt;Series&gt;This collection contains no series.&lt;/Series&gt;)
      }
    &lt;/Arrangement&gt;
  &lt;/Collection&gt;
}
&lt;/Repository&gt;
</pre>
</div>
<p>This script produces a &lt;Repository&gt; root tag containing a FLOWR expression. The for statement selects each file in the collection directory path/to/EAD/files and assigns it to a variable $collection. The first let statement declares the variable $info as a shortcut to the &lt;archdesc&gt; tag node. The second let statement assigns the collection level &lt;unitdate&gt; using the shortcut we just stated. </p>
<p>Notice that this statement also uses an XPath predicate to select only the unitdate tags with the attribute @type=“inclusive.” While this condition may also be written as an XQuery IF expression, it is much simpler here to use XPath because it uses only one line. While XPath predicates are necessary in XSLT to perform simple actions like this, in XQuery they are optional but often make queries much simpler.</p>
<p>Since some collections may also have bulk dates, limiting the $date variable to just one value allows the script to sort the collections using the order by statement. This line orders the collections according to their normalized date contained within the @normal attribute within the &lt;unitdate&gt; tag node.</p>
<p>The return statement adds some additional complexity. Here, for each collection the script produces a &lt;Collection&gt; tag with the children &lt;Title&gt;, &lt;Date&gt;, &lt;Size&gt;, and &lt;Arrangement&gt;. The first three children contain curly brackets with more XQuery code that produces the contents of the &lt;unittitle&gt; tag, the $date variable, and the &lt;physdesc&gt; tags respectively.</p>
<p>In the &lt;Arrangement&gt; tag, the script attempts to list the series titles from each collection. Since one of the collections contains no series, an IF expression is needed. First, the IF expression tests if the collection has any &lt;c01&gt; tags that have a @level attribute that equals “series.” If that statement is true, the Then statement activates another FLOWR expression that selects the &lt;unittitle&gt; of each &lt;c01&gt; tag and produces it within a &lt;Series&gt; tag. Here, there where statement is not necessary because of the if statement, but was retained because it shows that users can place a complete FLOWR expression within an IF expression. Lastly, if the If statement is false, the else statement produces a single &lt;Series&gt; tag that states that the collection has no series. The result of this script will be a short summary of collections encoded in EAD.</p>
<div class="figure">
  <img src="img/xquery2.jpg" width="1000" /></p>
<p><strong>Figure 2:</strong> Screenshot of XQuery script and result in BaseX GUI</p>
</div>
<p>This XQuery script is fairly complex for archivists without prior knowledge of XQuery or any other techniques for querying encoded data. It serves to demonstrate a small portion of the capabilities of XQuery and to give new users another example to experiment with. More complex scripts will force archivists to tackle the XQuery structure, which will likely be unfamiliar. It is very common to experience errors when curly brackets or parenthesis are omitted or misplaced. The best process is to start simple and build up from there. One of the major benefits to BaseX is that new users can run a simple query to confirm it works correctly and add to it later. Then, if errors are produced, users can just undo their changes and go back to a safe starting point.</p>
<h3>Results</h3>
<p>Archivists with a basic grasp of XQuery will be able to run simple reports and draw select information from their EAD finding aids. More advanced users will be able to reformat large volumes of legacy data, merge and split files, identify errors and inconsistencies, and perhaps derive data from finding aids for outreach, exhibitions, or other purposes. </p>
<p>One of the major hurdles for new XQuery users is to thoroughly understand their data. The structure of XML files can be very complex for users with more experience querying relational databases. Yet, the archives community has devoted substantial time and resources to thoroughly understanding EAD. This gives archivists familiar with EAD a distinct advantage. With a complete understanding of EAD and its structure, archivists with only a basic understanding of XQuery syntax can do tremendous things with their collection data.</p>
<p>There are many possible applications for XQuery. One example is a workflow tool developed at the University at Albany, SUNY to automate the creation of EAD finding aids. This tool utilizes a custom XML schema mapped to a Microsoft Excel workbook. Users enter collection-level data on the first sheet and the container list and series-level description on subsequent sheets. The workbook supports complex arrangements of up to three levels. Next the data is exported as XML and an XQuery script is activated that produces a complete and valid EAD finding aid.</p>
<p>Another possible application example is a tool to acquire metadata for digital images from volunteers or experts over the Internet. An archivist at the Marist Archives and Special Collections developed a prototype for this. The Metadata Creation Tool was designed to run on a web server running the open source eXist-db XML database. An archivist would upload digitized access images as JPEGs with unique IDs in each filename. An XQuery application provided a webpage through which off-site volunteers could select images and enter descriptive information with a simple web form. The web page was simple enough for use with only basic Internet experience. The descriptions were labeled with the unique IDs and entered into a running XML file, which other volunteers could add to simultaneously. An additional interface would be developed for reviewing the descriptions and for quality assurance. The simplicity of XQuery enabled this complex application to be developed in under two weeks, requiring only around 600 lines of code.</p>
<p>The use of XQuery also has one important added benefit: it forces archivists to see encoded finding aids as data. The archives community has invested heavily in developing EAD and other XML standards and tools. This is consistent with a long tradition of archivists focusing primarily on storage (both analog and digital) over use. As archivists have discovered in the paper world, it is difficult to have the foresight to develop effective storage processes without understanding how the stored materials will be used. Through learning and making use of XQuery to process EAD finding aids and other XML data, archivists will better understand how that data may be used, and in turn, better understand how to store and manage it. </p>
<p>For a practical example, say a novice XQuery user attempts to run a simple report to sort a list of EAD-encoded collections by extent. If the collection-level extent is encoded as &lt;extent label=“Extent”&gt;20.3 cubic ft.&lt;/extent&gt;, the query will fail. By making use of XQuery, and thinking of the &lt;extent&gt; tag as a discrete unit of data, it will become clear that, to sort collections by extent, it will need to be encoded as &lt;extent label=“Extent” unit=“cubic ft.”&gt;20.3&lt;/extent&gt;. In other words, actually using EAD data will help archivists to better understand it.</p>
<div class="about-author">
<h3>About the Author</h3>
<p>Gregory Wiedeman is currently the Project Archivist with the M. E. Grenander Department of Special  Collections &amp; Archives at the University at Albany, SUNY. He is working on the National Death Penalty Archive with a grant from the Council on Library and Information Resources (CLIR). He has previously worked on large scale processing and digitization projects at the Marist College Archives &amp; Special Collections, and the Dutchess County Historical Society. He holds an MS in Information Science and a MA in History from the University at Albany, SUNY.</p>
</div>
<h3>Further Resources</h3>
<p>BaseX: The XML Database, accessed July 9, 2014, <a href="http://www.basex.org" rel="nofollow">http://www.basex.org</a>.</p>
<p>eXist-db: The Open Source Native XML Database, accessed July 9, 2014, <a href="http://exist-db.org/exist/apps/homepage/index.html" rel="nofollow">http://exist-db.org/exist/apps/homepage/index.html</a>.</p>
<p>eXist-db: Documentation, accessed July 9, 2014, <a href="http://exist-db.org/exist/apps/doc" rel="nofollow">http://exist-db.org/exist/apps/doc</a>.</p>
<p>Fawcett, Joe, Liam R. E. Quin &amp; Danny Ayers, <em>Beginning XML</em> (Indianapolis: John Wiley &amp; Sons, Inc., 2012).</p>
<p>FunctX XQuery Functions: Hundreds of Useful Examples, accessed July 9, 2014, <a href="http://www.xqueryfunctions.com" rel="nofollow">http://www.xqueryfunctions.com</a>.</p>
<p>Saxon: The XSLT and XQuery Processor, accessed July 9, 2014, <a href="http://saxon.sourceforge.net" rel="nofollow">http://saxon.sourceforge.net</a>.</p>
<p>Stack Overflow, accessed July 9, 2014, <a href="http://www.stackoverflow.com" rel="nofollow">http://www.stackoverflow.com</a>.</p>
<p>Walmsley, Priscilla, <em>XQuery</em> (Sebastopol, CA: O’Reilly Media, Inc., 2007).</p>
<p>XQuery 3.0: An XML Query Language, accessed July 9, 2014, <a href="http://www.w3.org/TR/xquery-30" rel="nofollow">http://www.w3.org/TR/xquery-30</a>.</p>
<p>W3Schools XQuery Tutorial, accessed July 9, 2014, <a href="http://www.w3schools.com/xQuery/default.asp" rel="nofollow">http://www.w3schools.com/xQuery/default.asp</a>.</p>
<p>Zorba: The NoSQL Query Processor, accessed August 6, 2014, http:// <a href="http://www.zorba.io" rel="nofollow">http://www.zorba.io</a>.</p>
<h3>Appendix</h3>
<p>The following compares a section of an XSLT stylesheet that was part of the original EAD cookbook, with its equivalent in XQuery:</p>
<h3>XSLT</h3>
<pre class="brush: xml">
&lt;xsl:if test="child::unitdate[@type='inclusive']"&gt;
  &lt;xsl:choose&gt;
      &lt;xsl:when test="unitdate[@type='inclusive']/@label"&gt;
          &lt;tr&gt;
              &lt;td valign="top"&gt;
                  &lt;b&gt;
                  &lt;xsl:value-of select="unitdate[@type='inclusive']/@label"/&gt;
                  &lt;/b&gt;
              &lt;/td&gt;
              &lt;td&gt;
                  &lt;xsl:value-of select="unitdate[@type='inclusive']"/&gt;
              &lt;/td&gt;
          &lt;/tr&gt;
      &lt;/xsl:when&gt; 
      &lt;xsl:otherwise&gt;
          &lt;tr&gt;
              &lt;td valign="top"&gt;
                  &lt;b&gt;
                      &lt;xsl:text&gt;Dates: &lt;/xsl:text&gt;
                  &lt;/b&gt;
              &lt;/td&gt;
              &lt;td&gt;
                  &lt;xsl: value-of select="unitdate[@type='inclusive']"/&gt;
              &lt;/td&gt;
          &lt;/tr&gt;
      &lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:if&gt;
</pre>
<h3>XQuery</h3>
<pre class="brush: xml">
&lt;tr&gt;{
  for $date in unittitle/unitdate
  where $date/@type = ‘inclusive’
  return
      if (exists($date/@label))
      then (&lt;td valign="top"&gt;
              &lt;b&gt;{data{$date/@label}&lt;/b&gt;
            &lt;/td&gt;
            &lt;td&gt;{data($date)}&lt;/td&gt;)
      else (&lt;td valign="top"&gt;
              &lt;b&gt;Dates:&lt;/b&gt;
            &lt;/td&gt;
            &lt;td&gt;{data($date)}&lt;/td&gt;)
}&lt;/tr&gt;
</pre>
<div class="references">
<h3>Notes</h3>
<p><a id="ftn1" href="#ftnref1">1</a>. Sonia Yaco, “It’s Complicated: Barriers to EAD Implementation,” The American Archivist 71 (Fall/Winter 2008):467.</p>
<p><a id="ftn2" href="#ftnref2">2</a>. J. Gordon Daines &amp; Cory L. Nimer, “Re-Imagining Archival Display: Creating User-Friendly Finding Aids,” Journal of Archival Organization 9 (2011): 4-31. ArchivesSpace: <a href="http://www.archivesspace.org" rel="nofollow">http://www.archivesspace.org</a>. Princeton University Library Finding Aids: <a href="http://findingaids.princeton.edu" rel="nofollow">http://findingaids.princeton.edu</a>.</p>
<p><a id="ftn3" href="#ftnref3">3</a>. Stack Overflow: <a href="http://www.stackoverflow.com" rel="nofollow">http://www.stackoverflow.com</a>.</p>
<p><a id="ftn4" href="#ftnref4">4</a>. Steve Krug, Don’t Make Me Think: A Common Sense Approach to Web Usability (Berkeley, CA: New Riders Publishing, 2006).</p>
<p><a id="ftn5" href="#ftnref5">5</a>. Michael J. Fox, The EAD Cookbook (2000), <a href="http://saa-ead-roundtable.github.io/" rel="nofollow">http://saa-ead-roundtable.github.io/</a>.</p>
<p><a id="ftn6" href="#ftnref6">6</a>. Daines &amp; Nimer, 13-20.</p>
<p><a id="ftn7" href="#ftnref7">7</a>. SAXON: The XSLT and XQuery Processor: <a href="http://saxon.sourceforge.net" rel="nofollow">http://saxon.sourceforge.net</a>. Some variations of Saxon only run XQuery 1.0, while others can process the additional functions in XQuery 3.0.</p>
<p><a id="ftn8" href="#ftnref8">8</a>. eXist-db: The Open Source Native XML Database: <a href="http://exist-db.org/exist/apps/homepage/index.html" rel="nofollow">http://exist-db.org/exist/apps/homepage/index.html</a>.</p>
<p><a id="ftn9" href="#ftnref9">9</a>. Zorba: The NoSQL Query Processor: <a href="http://www.zorba.io" rel="nofollow">http://www.zorba.io</a>.</p>
<p><a id="ftn10" href="#ftnref10">10</a>. BaseX: The XML Database: <a href="http://www.basex.org" rel="nofollow">http://www.basex.org</a>.</p>
<p><a id="ftn11" href="#ftnref11">11</a>. FunctX XQuery Functions: <a href="http://www.xqueryfunctions.com" rel="nofollow">http://www.xqueryfunctions.com</a>.</p>
</div>
					</section>
                </div>
            </div>
        </div>
    </section>
	
	<!-- Footer Section -->
    <section id="footer" class="footer-section">
        <div class="container">
            <div class="row">
                <div class="col-sm-12">
                    <ul class="list-inline">
						<a href="https://twitter.com/GregWiedeman" class="btn btn-social-icon btn-twitter"><i class="fa fa-twitter fa-2x"></i></a>
						<a href="https://github.com/UAlbanyArchives" class="btn btn-social-icon btn-github"><i class="fa fa-github fa-2x"></i></a>
						<a href="https://www.linkedin.com/in/gregory-wiedeman-9a266b35" class="btn btn-social-icon btn-linkedin"><i class="fa fa-linkedin fa-2x"></i></a>
					</ul>
					<div class="licence">
						<a rel="license" href="http://creativecommons.org/licenses/by/3.0/us/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/3.0/us/88x31.png" /></a>
					</div>
                </div>
            </div>
        </div>
    </section>

    <!-- jQuery -->
    <script src="../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../js/bootstrap.min.js"></script>
	
	<!-- Scrolling Nav JavaScript -->
    <script src="../js/jquery.easing.min.js"></script>
    <script src="../js/scrolling-nav.js"></script>
	
	<script type="text/javascript">
		SyntaxHighlighter.all()
	</script>


</body>

</html>
